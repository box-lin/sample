{"meta":{"title":"myNoteBook","subtitle":"","description":"","author":null,"url":"http://boxianglin.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-08-08T05:01:02.134Z","updated":"2021-03-08T01:23:54.052Z","comments":true,"path":"categories/index.html","permalink":"http://boxianglin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-03-08T01:25:13.881Z","updated":"2021-03-08T01:25:13.881Z","comments":true,"path":"tags/index.html","permalink":"http://boxianglin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-01-20T04:01:46.928Z","updated":"2022-01-20T04:01:46.928Z","comments":true,"path":"tools/index.html","permalink":"http://boxianglin.github.io/tools/index.html","excerpt":"","text":"Tools"}],"posts":[{"title":"Custom Comparator Java and Python","slug":"CustomComparator","date":"2022-08-14T18:09:28.155Z","updated":"2022-08-14T18:17:32.952Z","comments":true,"path":"2022/08/14/CustomComparator/","link":"","permalink":"http://boxianglin.github.io/2022/08/14/CustomComparator/","excerpt":"","text":"In Java o2.compareTo(o1) if o2 &gt; o1 swap, so this is to reverse o1.compareTo(o2) if o1 &gt; o2 swap, so this is sort from low to high 1234x.compareTo(y) returns 1. negative value if x &lt; y //(x should appear first) 2. zero if x == y 3. positive value if x &gt; y //(x should apper second, need swap) In Python def __lt__(self, other) overrides the &lt; operator Example: 12345678def __lt__(self, other): if self.cnt &gt; other.cnt: return False elif self.cnt &lt; other.cnt: return True # (sorted respect to cnt from small ---large) else: # opposite sort return lt(other.word, self.word) # other.word &lt; self.word","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://boxianglin.github.io/categories/Programming-Language/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://boxianglin.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"http://boxianglin.github.io/tags/Java/"}]},{"title":"Disjoint-Set Data Structure","slug":"DisjointSet","date":"2022-01-16T07:31:23.722Z","updated":"2022-08-14T18:10:04.321Z","comments":true,"path":"2022/01/16/DisjointSet/","link":"","permalink":"http://boxianglin.github.io/2022/01/16/DisjointSet/","excerpt":"Disjoint-Set Visualization","text":"Disjoint-Set Visualization Optimized “disjoint set” with Path Compression and Union by Rank (From LeetCode)Unless worst case the average cases will be more efficient.12345678910111213141516171819202122232425262728293031# UnionFind classclass UnionFind: def __init__(self, size): self.root = [i for i in range(size)] # Use a rank array to record the height of each vertex, i.e., the &quot;rank&quot; of each vertex. # The initial &quot;rank&quot; of each vertex is 1, because each of them is # a standalone vertex with no connection to other vertices. self.rank = [1] * size # The find function here is the same as that in the disjoint set with path compression. def find(self, x): if x == self.root[x]: return x self.root[x] = self.find(self.root[x]) return self.root[x] # The union function with union by rank def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] &gt; self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] &lt; self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1 def connected(self, x, y): return self.find(x) == self.find(y) Quick Find1234567891011121314151617181920class UnionFind: def __init__(self, size): self.root = [i for i in range(size)] # O(1) def find(self, x): return self.root[x] # O(N) def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: for i in range(len(self.root)): if self.root[i] == rootY: self.root[i] = rootX #O(1) def connected(self, x, y): return self.find(x) == self.find(y) Quick Union123456789101112131415161718class UnionFind: def __init__(self, size): self.root = [i for i in range(size)] # def find(self, x): while x != self.root[x]: x = self.root[x] return x def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: self.root[rootY] = rootX def connected(self, x, y): return self.find(x) == self.find(y)","categories":[{"name":"Data Structures","slug":"Data-Structures","permalink":"http://boxianglin.github.io/categories/Data-Structures/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"http://boxianglin.github.io/tags/Data-Structures/"}]},{"title":"Trie Data Structure","slug":"Trie","date":"2022-01-16T06:38:48.516Z","updated":"2022-08-14T18:11:19.671Z","comments":true,"path":"2022/01/16/Trie/","link":"","permalink":"http://boxianglin.github.io/2022/01/16/Trie/","excerpt":"Trie Visualization","text":"Trie Visualization Python Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546&quot;&quot;&quot;For Node Instance with attribute - child (edge)- is_end (leaf)&quot;&quot;&quot;class Node: def __init__(self): self.child = &#123;&#125; self.is_end = False &quot;&quot;&quot;Trie structure that holds collection of Node.&quot;&quot;&quot;class Trie: def __init__(self): self.root = Node() def insert(self, word: str) -&gt; None: # cur pointer traverse trie from root cur = self.root for c in word: if not c in cur.child: # set current node edge in a weight of character to a new node cur.child[c] = Node() # traverse to the end cur = cur.child[c] cur.is_end = True def search(self, word: str) -&gt; bool: cur = self.root for c in word: if c not in cur.child: return False cur = cur.child[c] # see if can reach to leaf return cur.is_end def startsWith(self, prefix: str) -&gt; bool: cur = self.root for p in prefix: if p not in cur.child: return False cur = cur.child[p] return True","categories":[{"name":"Data Structures","slug":"Data-Structures","permalink":"http://boxianglin.github.io/categories/Data-Structures/"}],"tags":[{"name":"Data Structures","slug":"Data-Structures","permalink":"http://boxianglin.github.io/tags/Data-Structures/"}]},{"title":"Numerically Solve PDE","slug":"NumericallyPDE","date":"2021-05-23T00:23:13.928Z","updated":"2022-01-16T09:49:22.595Z","comments":true,"path":"2021/05/22/NumericallyPDE/","link":"","permalink":"http://boxianglin.github.io/2021/05/22/NumericallyPDE/","excerpt":"For phone user, the css might not be properly rendered for MathJax, please visit the pdf file at here Sample Partial Differential Equation \\begin{align*} &amp; \\text{Suppose given the PDE (Diffusion)} \\\\ &amp; \\partial_tu=D\\partial_x^2u,\\ for\\ x\\ \\in[0,1],and\\ t&gt;0\\\\ \\\\ &amp; \\text{Exact Solution (can be found in multiple PDEs textbooks): }\\\\ &amp; u(x,t) = \\sum_{k=1}^{n}=\\frac{4}{(k\\pi)^2}sin(\\frac{k\\pi}{2})sin(k\\pi x)e^{-0.5(k\\pi )^2t}\\\\ \\\\ &amp; \\text{We are going to compute the numerical solution with }\\\\ &amp; \\text{the given information below. }\\\\ \\\\ &amp; \\text{for }x \\in[0,1] \\text{ and t &gt; 0 :}\\\\ &amp; the\\ initial\\ condition\\ u(x,0)=\\begin{cases} x, &amp; \\text{if } 0\\leq x \\leq 1/2\\\\ 1-x, &amp; \\text{if } 1/2 &lt; x\\leq1 \\end{cases}\\\\ &amp;\\text{the boundary condition } u(0,t)=u(1,t)=0 \\\\ \\\\ &amp; \\text{The Explicit Difference Schema: }\\\\ &amp; \\frac{u_j^{n+1}-u_j^n}{\\Delta t}= D\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}, where\\ D=\\frac{1}{2}\\\\ \\\\ &amp;\\text{Take }\\Delta x=0.1, \\Delta t=1/100 \\text{ to proceed the calculations;} \\end{align*}","text":"For phone user, the css might not be properly rendered for MathJax, please visit the pdf file at here Sample Partial Differential Equation \\begin{align*} &amp; \\text{Suppose given the PDE (Diffusion)} \\\\ &amp; \\partial_tu=D\\partial_x^2u,\\ for\\ x\\ \\in[0,1],and\\ t&gt;0\\\\ \\\\ &amp; \\text{Exact Solution (can be found in multiple PDEs textbooks): }\\\\ &amp; u(x,t) = \\sum_{k=1}^{n}=\\frac{4}{(k\\pi)^2}sin(\\frac{k\\pi}{2})sin(k\\pi x)e^{-0.5(k\\pi )^2t}\\\\ \\\\ &amp; \\text{We are going to compute the numerical solution with }\\\\ &amp; \\text{the given information below. }\\\\ \\\\ &amp; \\text{for }x \\in[0,1] \\text{ and t &gt; 0 :}\\\\ &amp; the\\ initial\\ condition\\ u(x,0)=\\begin{cases} x, &amp; \\text{if } 0\\leq x \\leq 1/2\\\\ 1-x, &amp; \\text{if } 1/2 &lt; x\\leq1 \\end{cases}\\\\ &amp;\\text{the boundary condition } u(0,t)=u(1,t)=0 \\\\ \\\\ &amp; \\text{The Explicit Difference Schema: }\\\\ &amp; \\frac{u_j^{n+1}-u_j^n}{\\Delta t}= D\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}, where\\ D=\\frac{1}{2}\\\\ \\\\ &amp;\\text{Take }\\Delta x=0.1, \\Delta t=1/100 \\text{ to proceed the calculations;} \\end{align*} Solving Idea for a particular t \\begin{align*} &amp; \\text{Use of the finite difference scheme for discretizing partial derivatives}\\\\ &amp; \\text{reduces the problem to vector-matrix multiplication.}\\\\ \\\\ &amp; \\text{Where the unknown vector }U^n=(U_1^n,U_2^n,...U_N^n)^T\\text{ refers to sample}\\\\ &amp; \\text{of grid values of the solution function }u(x,t) \\text{ evaluated at } t = t_n.\\\\ \\\\ &amp; \\text{Then what we focuse on for }u_j^n=u(x_j,t_n) \\text{ is in a vector of }U^n to\\ U^{n+1} \\\\ \\\\ &amp; \\text{To calculated the }U^{n+1} , \\text{we must use the explicit difference scheme} \\end{align*} A Look of Explicit Difference Scheme Equation \\begin{align*} &amp; \\text{As we said we interested the vector }U^{n+1} = \\text{a set of } u_j^{n+1} j\\in[1,11],\\\\ &amp; \\text{for the case that }\\Delta x= 0.1, x\\in[0,1]\\\\ \\\\ &amp; \\text{Hence we would like to rearrange the equation to:}\\\\ \\\\ &amp; u_j^{n+1}= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}(u_{j+1}^n-2u_j^n+u_{j-1^n})+u_j^n\\\\ &amp; = u(x_j,t_{n+1})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_n)-2u(x_j,t_n)+u(x_{j-1},t_n)]+u(x_j,t_n)\\\\ \\\\ &amp; \\text{for easier programming purpose, we shift the index of t left by one}\\\\ &amp; = u(x_j,t_{n})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_{n-1})-2u(x_j,t_{n-1})+u(x_{j-1},t_{n-1})]+u(x_j,t_{n-1}) \\end{align*} A Look of How Initial and Boundary Condition are Important \\begin{align*} &amp; \\text{The expression of } u(x,t)\\text{ in 2D matrix: }\\\\ \\\\ &amp; \\begin{matrix} &amp; 1 &amp; 2&amp;3&amp; \\cdots&amp;n\\\\ 1&amp; u(0,0) &amp; u(0, 1\\Delta t) &amp; u(0,2\\Delta t) &amp; \\cdots &amp; u(0,n\\Delta t) \\\\ 2&amp; u(1 \\Delta x,0) &amp; \\cdots &amp; \\cdots&amp; \\cdots&amp; u(1\\Delta x,n\\Delta t) \\\\ 3&amp; u(2 \\Delta x, 0) &amp; \\cdots&amp; \\cdots&amp; \\cdots&amp; u(2\\Delta x,n\\Delta t)\\\\ &amp;.\\\\ &amp;. \\\\ 11&amp; u(1,0) &amp;\\end{matrix}\\\\ \\\\ &amp;\\text{The initial condition cover the values for first columns}\\\\ &amp;\\text{And the boundary condition cover the values for first and last rows}\\\\ \\\\ &amp;\\text{Now, the expression of }u(x,t) \\text{ should be:} \\\\ \\\\ &amp; \\begin{matrix} &amp; 1 &amp; 2&amp;3&amp; \\cdots&amp;n\\\\ 1&amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 2&amp; 0.1 &amp; u(1\\Delta x,1\\Delta t) &amp; \\cdots&amp; \\cdots&amp; u(1\\Delta x,n\\Delta t) \\\\ 3&amp; 0.2 &amp; u(2\\Delta x,1\\Delta t) &amp; \\cdots&amp; \\cdots&amp; u(2\\Delta x,n\\Delta t)\\\\ &amp;.\\\\ 5&amp; 0.5 &amp;\\cdots&amp; \\cdots&amp; \\cdots&amp; \\\\ 6&amp; 0.4 &amp; \\cdots&amp; \\cdots&amp; \\cdots&amp; \\\\ 7&amp; 0.3 &amp;\\cdots&amp; \\cdots&amp; \\cdots&amp; \\\\ &amp;. \\\\ 11&amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp;\\end{matrix}\\\\ \\\\ \\\\ &amp; \\text{Now from this matrix, we see the pattern of how explicit difference help}\\\\ &amp; \\text{us to calculate the } u(x_j,t_n);\\\\ \\\\ &amp; \\text{For example: }u(x_2,t_2),\\text{we need }u(x_1,t_1)，u(x_2,t_1),u(x_3,t_1)&#039;s \\text{ values}\\\\ &amp;\\text{to explicit difference equation: }\\\\ &amp; u(x_j,t_{n})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_{n-1})-2u(x_j,t_{n-1})+u(x_{j-1},t_{n-1})]+u(x_j,t_{n-1})\\\\ \\\\ &amp; \\text{Hence we know we must calculated the current columns&#039;s val then proceed to}\\\\ &amp; \\text{proceed to the row, }U^n = \\text{each columns value, and } U^{n+1} =\\text{next columns value} \\end{align*} MATLAB Implementations 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687clearclose allprompt = &#x27;Enter the value of ∆t: &#x27;;% set t_max= x then coloumns needed = x / delta_t + 1% row = 1/ (0.01) + 1 = 11 (by default x[0,1]delta_t = input(prompt);prompt1 = &#x27;Enter the value of T(max): &#x27;;column = input(prompt1) / delta_t + 1 ;row = 11;% 2-D array with all zeros for exact solutionarr1 = zeros(row,column);% initial variables for exact solutionresult = 0;arr1_x = 0;arr1_t = 0;% exact solution% taking 14 termsfor i = 1:row for j = 1:column for k = 1:14 result = result + 4/(k*pi)^2*sin(k*pi/2)*sin(k*pi*arr1_x)*exp(-0.5*(k*pi)^2*arr1_t); end arr1(i,j) = result; arr1_t = arr1_t + delta_t; result = 0; end arr1_t = 0; arr1_x = arr1_x + 0.1;end% Numerical Computing Solution% (Initial Condition)arr2 = zeros(row,column);x_num = 0;for i = 1 : row if(x_num&gt;0.5) arr2(i,1) = 1-x_num; else arr2(i,1) = x_num; end x_num = x_num + 0.1;end% applied explicit differences to calculate other points% applied boundary condition as welldt = delta_t;dx = 0.1;for j = 2: column for i = 1:row if (i == 1 || i == row) arr2(i,j) = 0; else arr2(i,j) =0.5 *dt/(dx)^2*(arr2(i+1, j-1)-2*arr2(i,j-1)+arr2(i-1,j-1))+arr2(i,j-1); end endend% Error |Exact - Numerical|error = zeros(row, column);for i = 1 : row for j = 1 : column error(i,j) = abs(arr1(i,j)- arr2(i,j)); endend%% plot Portionx_ = 0:0.1:1;prompt_1 = &#x27;Enter the value of t to get the graph u(x,t) at t =: &#x27; ;t = input(prompt_1);exctVal = arr1(:, t/delta_t+1 );numVal = arr2(:, t/delta_t+1 );plot (x_,numVal,x_,exctVal,&#x27;lineWidth&#x27;, 2);hold offxlabel(&#x27;x&#x27;);s = num2str(t);txt = [&#x27;u(x,t), t= &#x27;, s];ylabel(txt);legend(&#x27;Numerical&#x27;,&#x27;Exact&#x27;); Graphical Output","categories":[{"name":"Fun Post","slug":"Fun-Post","permalink":"http://boxianglin.github.io/categories/Fun-Post/"}],"tags":[{"name":"Fun Post","slug":"Fun-Post","permalink":"http://boxianglin.github.io/tags/Fun-Post/"}]}],"categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://boxianglin.github.io/categories/Programming-Language/"},{"name":"Data Structures","slug":"Data-Structures","permalink":"http://boxianglin.github.io/categories/Data-Structures/"},{"name":"Fun Post","slug":"Fun-Post","permalink":"http://boxianglin.github.io/categories/Fun-Post/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://boxianglin.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"http://boxianglin.github.io/tags/Java/"},{"name":"Data Structures","slug":"Data-Structures","permalink":"http://boxianglin.github.io/tags/Data-Structures/"},{"name":"Fun Post","slug":"Fun-Post","permalink":"http://boxianglin.github.io/tags/Fun-Post/"}]}