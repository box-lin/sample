{"meta":{"title":"Boxiang's Blog","subtitle":"","description":"","author":"Boxiang Lin","url":"http://boxianglin.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-03-08T01:23:54.052Z","updated":"2021-03-08T01:23:54.052Z","comments":true,"path":"categories/index.html","permalink":"http://boxianglin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-03-08T01:25:13.881Z","updated":"2021-03-08T01:25:13.881Z","comments":true,"path":"tags/index.html","permalink":"http://boxianglin.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-12T00:52:44.711Z","updated":"2021-09-12T00:52:44.711Z","comments":true,"path":"projects/index.html","permalink":"http://boxianglin.github.io/projects/index.html","excerpt":"","text":"Projects | Boxiang's Blog PROJECTS File Compressor Library Management FPGA Stop Watch Snake Game Project Lists"},{"title":"","date":"2021-08-14T04:35:20.704Z","updated":"2021-08-14T04:35:20.704Z","comments":true,"path":"projects/style.css","permalink":"http://boxianglin.github.io/projects/style.css","excerpt":"","text":"body{ margin: 0; background-color: #f5f5f5; display: flex; flex-direction: column; height: 100vh; /* 用flex划空间需要父元素有个具体的尺寸 */ -webkit-tap-highlight-color: transparent; } header{ height: 40px; background-color: #333; flex-shrink: 0; /* 默认值为1 */ } nav{ border-bottom: 1px solid #e6e6e6; height: 80px; display: flex; justify-content: center; } nav a{ text-decoration: none; /* 去掉下划线 */ font-size: 20px; color: #000; padding: 30px 10px; margin: 0 20px; /* 这样可以做出线分开的感觉 */ } nav a:hover{ color: #ff6700; border-bottom: 3px solid #ff6700; transition: all .2s; -webkit-transition: all .2s; -moz-transition: all .2s; -ms-transition: all .2s; -o-transition: all .2s; /*这些是兼容性代码*//*自动生成是靠的Autoprefixer插件*//*兼容这些浏览器的老版本,在那些版本里这是实验性功能*/; } .showcase{ flex-grow: 1; /* 意思是header:nav:div.showcase:footer=0:0:1:0 */ margin-top: 20px; /* 之前的空行也是，为的是分开对自己的设置和对子元素的设置，好读 */ display: flex; justify-content: center; flex-wrap: wrap; align-content: start; /* 如果.showcase a的个数很少的话这句话是必要的哦 */ } .showcase a{ /*width: 270px;*/ width: 550px; /*width: 150px; */ /*height: 180px;*/ height: 325px; background-color: #fff; margin: 20px; transition-property: transform, box-shadow; transition-duration: .3s, .3s; /* 特定多个对象的话,不能用transition的嘞 */ /* transition本身就是tp和tduration和tdelay的简写来着 */ text-decoration: none; } .showcase a:hover{ transform: translateY(-8px); -webkit-transform: translateY(-8px); -moz-transform: translateY(-8px); -ms-transform: translateY(-8px); -o-transform: translateY(-8px); box-shadow: 0 10px 20px rgba(0, 0, 0, .1); } /* hover在移动端的效果不大好 */ /* 可以用@media给移动端来点特殊效果 */ /* 但是本视频就先不涉及@media了 */ .showcase a img{ /*width: 270px;*/ width: 550px; height: 300px; } .showcase a span{ display: block; text-align: center; color: #595959; font-weight:bold; font-style:oblique; } footer{ text-align: center; }"},{"title":"About","date":"2021-09-25T07:19:08.261Z","updated":"2021-09-25T07:19:08.261Z","comments":true,"path":"about/index.html","permalink":"http://boxianglin.github.io/about/index.html","excerpt":"","text":"##Intro I am currently pursuing a Bachelor of Science in Computer Science at Washington State University. I comprehend myself as a warrior with an exploratory spirit and self-discipline. I am ready for the industry and will do all my best to dedicate myself in and on. ##Education #####Washington State University B.S. in Computer Science : Aug 2020 - Exp Grad: May 2023 Course: Advanced Data Structure, Computer Architecture, Numerical Analysis, Big Data, Software Engineering, Object-Oriented Software Principles, Professional Computing. Cumulative GPA: 3.93/4.00 #####Seattle Central College A.S. in Computer Science : Sep 2019 - June 2020 Course: Calculus 1-3, Differential Equation, Engineering Physics I-III, Java Programming, Java Data Structure, Statistic Cumulative GPA: 3.9/4.00 ##Work Experience #####Washington State University | Teaching Assistant : Jan 2021 - Current (Pullman, WA) TA for courses Cpt_S 132 (Java Data Structure) and Cpt_S 233 (Advance Data Structure). Setup the Docker container and Gitlab runner on the server to run the test suit through the Gitlab CI/CD pipeline. Distribute the assignments projects through Gitlab in a fashion of industry git version-control environment. Grade the assignments, projects, and exams; provide two office hours each week to help student success. #####Computer Electronics Outlet | Software Support Assistant : July 2018 - Dec 2018 (Saipan, MP) Install windows operating system; Configure the software and drivers; Troubleshoot system and software failures; Setup the modem admin account. #####Joint Marketing | Real Estate Assistant (Part Time) : Mar 2016 - May 2018 (Saipan, MP) Provide property description and coordinate on-site show to the customers. Maintain the electronic and paper file system for property and customer information. ##Projects ######Library Management System Tools used: Java Swing, Java Database Connectivity, MySQL, and Window-builder for GUI. An application that modifies the data for the book in the database through MySQL upon the Java Swing GUI interaction. Functionalities are addition, deletion, and search for a category or a single book. ######Stop Watch FPGA Tools used: Verilog, FPGA Board. The program is built on the FPGA board. It enables the four seven-segment to display as a watch that is controlled by four buttons. The buttons’ functionalities are: start, stop, increment, and clear."}],"posts":[{"title":"Finite State Machine Design","slug":"FiniteStateMachine","date":"2021-09-12T00:21:30.970Z","updated":"2021-09-12T00:47:53.199Z","comments":true,"path":"2021/09/11/FiniteStateMachine/","link":"","permalink":"http://boxianglin.github.io/2021/09/11/FiniteStateMachine/","excerpt":"Finite State Machine DesignGot this question wrong in the Homework and I think it is a bit complicated to just design the DFA on your mind. To do the DFA for this question, the conversion from an e-NFA to DFA, indeed, could be more accessible.","text":"Finite State Machine DesignGot this question wrong in the Homework and I think it is a bit complicated to just design the DFA on your mind. To do the DFA for this question, the conversion from an e-NFA to DFA, indeed, could be more accessible. Build the C.1 condition DFA is easy but to combine both them into a complete DFA is hard to manage (at least for me). So in here we will build the e-NFA for the C.1 and C.2 by using an empty string to connect them up. The below e-NFA diagram shows the upper branch handles the C.1 condition and lower branch handles the C.2 condition. The Corresponding Transition Table: Now applied LAZY SUBSET CONSTRUCTION for conversion (DFA transition table) According to the e-NFA diagram we know that qi, q2, q1’ are all accepted states, so from any union of state above include them are all gonna be accepted states in DFA as well (the bold states are acceptable). For easier diagram purpose we can rename each union of state a new name, I will adhere to above convention, then draw the the DFA according to the DFA transition table:","categories":[{"name":"Automata and Formal Languages","slug":"Automata-and-Formal-Languages","permalink":"http://boxianglin.github.io/categories/Automata-and-Formal-Languages/"}],"tags":[{"name":"Automata and Formal Languages","slug":"Automata-and-Formal-Languages","permalink":"http://boxianglin.github.io/tags/Automata-and-Formal-Languages/"}]},{"title":"Compute the time available for meetings","slug":"MeetingsCompute","date":"2021-06-16T05:18:24.353Z","updated":"2021-07-07T17:41:36.591Z","comments":true,"path":"2021/06/15/MeetingsCompute/","link":"","permalink":"http://boxianglin.github.io/2021/06/15/MeetingsCompute/","excerpt":"Phone users pls visit the pdf here Generate a List of Available Time for Meetings Input: Person1: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Person2: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Meeting_time frame: 30 minutes at least Output: Return a nested list of all available time to schedule meetings for Person1 and Person2 example: 12345678Input:p1_schedule &#x3D; [[&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;],[&#39;18:30&#39;,&#39;19:00&#39;]]p2_schedule &#x3D; [[&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;]]p1_daily_bound &#x3D; [&#39;9:00&#39;,&#39;20:00&#39;]p2_daily_bound &#x3D; [&#39;10:00&#39;,&#39;18:30&#39;]meeting_time &#x3D; 30output: [[&#39;15:00&#39;, &#39;16:00&#39;], [&#39;18:00&#39;, &#39;18:30&#39;]]","text":"Phone users pls visit the pdf here Generate a List of Available Time for Meetings Input: Person1: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Person2: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Meeting_time frame: 30 minutes at least Output: Return a nested list of all available time to schedule meetings for Person1 and Person2 example: 12345678Input:p1_schedule &#x3D; [[&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;],[&#39;18:30&#39;,&#39;19:00&#39;]]p2_schedule &#x3D; [[&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;]]p1_daily_bound &#x3D; [&#39;9:00&#39;,&#39;20:00&#39;]p2_daily_bound &#x3D; [&#39;10:00&#39;,&#39;18:30&#39;]meeting_time &#x3D; 30output: [[&#39;15:00&#39;, &#39;16:00&#39;], [&#39;18:00&#39;, &#39;18:30&#39;]] Pre 1. Formal Definition of Input \\begin{align*} &amp; \\text{Suppose } P \\text{ is a list of schedules for a particular day that contains } t _{(i,j)}^{N} \\text{ where t is a schedule between i to j time at Nth index of P } \\\\ &amp; \\text{We are also given a list of B that map to a P, where B contains two values } B_0\\ and \\ B_1 \\\\ &amp; \\text{Now, each input comply with the conditions below: }\\\\ &amp; \\text{} \\end{align*} \\begin{align*} &amp; p1.1)\\ B_0 \\leq [ t_{(i,j)}^N \\in P] \\leq B_1 \\\\ &amp; p1.2)\\ t_i &lt; t_j \\leq t_{i+1} &lt; t_{j+1} \\leq t_{N=i}&lt;t_{N=j}\\\\ \\end{align*} Pre 2. Formal Definition of Output \\begin{align*} &amp; \\text{Suppose O list contains time segments } T_{(i,j)}^M \\text{, O should be comply with below conditions} \\\\ \\\\ &amp; \\text{Suppose, }\\Delta t1_N = (t1_{j=0},t1_{i=1}),.....,(t1_{j=N-1},t1_{i=N}), \\text{so is } \\Delta t2_N\\\\ &amp; p2.1)\\ \\forall T_{(i,j)}^M \\not \\subset (\\Delta t1_N + \\Delta t2_N) \\\\ &amp; p2.2)\\ Max(B(0)_0, B(1)_0) \\leq \\forall\\ T_{(i,j)}^M \\leq Min(B(0)_0, B(1)_1) \\text{ where $B(x)$, $x$ represent a particular person}\\\\ &amp; p2.3)\\ T_i &lt; T_j \\leq T_{i+1 } &lt; T_{j+1} \\end{align*} Step 1. Determine The Final Bound Between Two Persons Pick the largest B0B_0B0​ and smallest B1B_1B1​ between B(x)B(x)B(x) to be Final Bound, we have to use this to cut off the out-of-bound time segments. $ s1.1) finalBound = [max(B(0)_0,B(1)_0,min(B(0)_1,B(1)_1)]$ Step 2. Combine Both P lists Since we know schedules of each P in sorted. We could merge both P lists by sorted order of tit_iti​. Let the merge list called CCC, then CCC has this unique condition to be aware of: s2.1) ∀C(i,j)N1+N2=S,Ci≤Cj and Ci≤Ci+1 holds, but Cj≰Ci+1 and Cj≰Cj+1 turns out to be not necessarys2.1)\\ \\forall C_{(i,j)}^{N1+N2 = S},C_i \\leq C_j \\ and\\ C_i\\leq C_{i+1} \\text{ holds, but } C_{j} \\not \\leq C_{i+1} \\ and \\ C_j\\not \\leq C_{j+1} \\text{ turns out to be not necessary} s2.1) ∀C(i,j)N1+N2=S​,Ci​≤Cj​ and Ci​≤Ci+1​ holds, but Cj​​≤Ci+1​ and Cj​​≤Cj+1​ turns out to be not necessary 12Take the example above:C &#x3D; [[&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;], [&#39;18:30&#39;, &#39;19:00&#39;]] Notice from above example: $C_{j=0} (‘10:45’) &gt; C_{i=1}(‘10:00’) $ and $C_{j=0} (‘10:45’) &gt; C_{j=1}(‘10:30’) $ Step 3. Trim The Combine List We have to trim the Combine List, the purpose is to trim the C list to below condition: \\begin{align*} &amp; s3.1) \\text{Place the upper bound to first index } C= [finalBound[0],finalBound[0]]+C_{i,j}^S\\\\ &amp; s3.2) \\ \\forall C_{i}^{S},\\forall C_j^S\\leq finalBound[1] \\text{ , To acheive this we have to do the followings combine list modifications :} \\\\ \\end{align*} \\begin{align*} &amp; =\\begin{cases} C_i^S \\geq finalBound[1], &amp; \\text{Remove current } C_{i,j}^S \\\\ C_i^S\\leq finalBound[1] \\ and\\ C_j^S&gt;finalBound[1], &amp; finalBound[1] = C_i^s \\text{ (We pick the smallest possible i) and } C_j^S=C_i^S \\end{cases} \\\\ \\\\ &amp; s3.3) \\text{Append [finalBound[1],finalBound[1]] to C} \\end{align*} finalBound for the example is = [‘10:00’,‘18:30’]: After s3.1, s3.2, s.3.3, C for the example above will be: 1C &#x3D; [[&#39;10:00&#39;, &#39;10:00&#39;], [&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;], [&#39;18:30&#39;, &#39;18:30&#39;]] Step 4. Main Logic: Compute the O (Output) Lets first assuming our C has this inequality relation Ci≤Cj≤Ci+1≤Cj+1C_i\\leq C_j \\leq C_{i+1} \\leq C_{j+1}Ci​≤Cj​≤Ci+1​≤Cj+1​ then we are confident to say that each $ [C_j, C_{i+1}] = T_{i = j,j = i+1} if\\ \\geq 30\\ minutes$ is a solution. Why? \\begin{align*} &amp; \\text{Proof}\\\\ &amp; \\text{Given the above inequality C possess of, and indecies are defined and bounded }i,j \\in \\mathbb{Z}, 0\\leq i,j\\leq S;\\\\ &amp; \\text{We know: }[finalBound[0], finalBound[1]] = [C_{i=0},C_{j=0})+[C_{i=0},C_{j=1}]+(C_i,C_j)+[C_{i=j},C_{i+1}]+.....(C_{i=S},C_{j=S}] \\\\ &amp; \\text{By definition of this sorted inequality, this shows each single C that sums up the the range in finalBound does not have overlaps} \\\\ &amp; \\text{Hence, }\\forall [C_{j,}, C_{i+1}] \\text{ are the solutions because } = 1-(C_{0&lt;i&lt;S}^S,C_{0&lt;j&lt;S}^S)-[C_{i0},C_{j0})-(C_{iS},C_{jS}]. \\end{align*} Which turns out if Cj&gt;Ci+1 or Cj&gt;Cj+1C_j &gt; C_{i+1} \\ or\\ C_j &gt; C_{j+1}Cj​&gt;Ci+1​ or Cj​&gt;Cj+1​ the [Cj,Ci+1][C_j, C_{i+1}][Cj​,Ci+1​] is not a solution, intuitively, that the first case resulting negative time range, and second case producing overlaps which shows (Ci,Cj)⊆[Cj,Ci+1](C_i, C_j) \\subseteq [C_j, C_{i+1}](Ci​,Cj​)⊆[Cj​,Ci+1​] \\begin{align*} &amp; \\text{Mechanism is to loop through the C list from index 0 to S and do the followings each iteration: }\\\\ \\\\ &amp; =\\begin{cases} C_j&gt;C_{i+1}\\ and\\ C_j\\leq C_{j+1} , &amp; \\text{Skip Current } C_{i,j} \\\\ C_j&gt;C_{i+1}\\ and\\ C_j&gt; C_{j+1} , &amp; \\text{Skip Current } C_{i,j} \\text{ and marked } C_{j+1} = C_j \\\\ C_j \\leq C_{i+1} \\ then \\ of \\ course\\ C_j\\leq C_{j+1},&amp; [C_j,C_{i+1}] \\text{ is solution if } \\geq 30\\ min \\\\ \\end{cases} \\\\ \\end{align*} Python Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111##################################---MAIN FUNCTION --- ##################################def aSchedule(p1S, p2S, p1B, p2B, meet_time): res = [] #Step 1 final_bound = dailyBound(p1B, p2B) #Step 2 and 3 combineS = combine(p1S, p2S,final_bound) temp_end = [] #Step 4 for i in range(1, len(combineS)): if temp_end: prev_end = temp_end[0] temp_end.pop() else: prev_end = combineS[i - 1][1] start = combineS[i][0] end = combineS[i][1] # Main Logic----- if compare(start, prev_end) &lt;= 0: # if end &lt; prev_end, prev_end should be the next (prev_end) to compare with the start if compare(end,prev_end) &lt; 0: temp_end.append(prev_end) elif compare(start, prev_end) &gt; 0: # start &gt; prev_end if difference(prev_end, start) &gt;= meet_time: # start - prev_end &gt;= meet_time res.append([prev_end, start]) return res###################################################################################def dailyBound(p1B, p2B): finalBound = [] # pick largest start if compare(p1B[0],p2B[0]) &gt;= 0: finalBound.append(p1B[0]) else: finalBound.append(p2B[0]) # pick smallest start if compare(p1B[1],p2B[1]) &lt;= 0: finalBound.append(p1B[1]) else: finalBound.append(p2B[1]) return finalBound## &lt;&lt;Helper&gt;&gt; combine two sorted nested array#def combine(p1S, p2S,final_bound): combine = [] combine.append([final_bound[0],final_bound[0]]) i, j = 0, 0 while i &lt; len(p1S) and j &lt; len(p2S): if compare(p1S[i][0], p2S[j][0]) &lt; 0: combine.append(p1S[i]) i += 1 else: combine.append(p2S[j]) j += 1 while i &lt; len(p1S): combine.append(p1S[i]) i += 1 while j &lt; len(p2S): combine.append(p2S[j]) j += 1 # Remove the largest schedule beyong the final_bound and search for potentially new end bound new_bound = [] for i in range(len(combine)): # when start &lt; finalbound but end &gt;= finalbound, [i] = [start,start] if compare(combine[i][0],final_bound[1]) &lt;= 0 and compare(combine[i][1], final_bound[1]) &gt; 0: combine[i] = [combine[i][0],combine[i][0]] if not new_bound: #we only take the first encounter one to be new bound new_bound.append(combine[i][0]) final_bound[1] = new_bound[0] # since the prev if condition valid, this will not execute, but next loops it will remove start &gt;= finalBound if compare(combine[i][0],final_bound[1]) &gt;= 0: combine.remove(combine[i]) combine.append([final_bound[1],final_bound[1]]) return combine## &lt;&lt;Helper&gt;&gt; compare#def compare(t1, t2): hr1, min1 = t1.split(&#x27;:&#x27;) hr2, min2 = t2.split(&#x27;:&#x27;) t1 = int(hr1) * 60 + int(min1) # t1 total minutes t2 = int(hr2) * 60 + int(min2) # t2 total minutes if t1 &lt; t2: return -1 elif t1 &gt; t2: return 1 else: return 0def difference(t1, t2): hr1, min1 = t1.split(&#x27;:&#x27;) hr2, min2 = t2.split(&#x27;:&#x27;) t1 = int(hr1) * 60 + int(min1) # t1 total minutes t2 = int(hr2) * 60 + int(min2) # t2 total minutes return t2 - t1p1S = [[&#x27;9:00&#x27;, &#x27;10:45&#x27;], [&#x27;10:45&#x27;, &#x27;13:00&#x27;], [&#x27;16:00&#x27;, &#x27;18:00&#x27;],[&#x27;18:30&#x27;,&#x27;19:00&#x27;]]p2S = [[&#x27;10:00&#x27;, &#x27;10:30&#x27;], [&#x27;10:30&#x27;, &#x27;14:30&#x27;], [&#x27;14:30&#x27;, &#x27;15:00&#x27;], [&#x27;16:00&#x27;, &#x27;17:00&#x27;]]p1B = [&#x27;9:00&#x27;,&#x27;20:00&#x27;]p2B = [&#x27;10:00&#x27;,&#x27;18:30&#x27;]print(aSchedule(p1S, p2S, p1B, p2B, 30))","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/tags/Algorithms/"}]},{"title":"Numerically Solve PDE","slug":"NumericallyPDE","date":"2021-05-23T00:23:13.928Z","updated":"2021-05-28T04:33:21.287Z","comments":true,"path":"2021/05/22/NumericallyPDE/","link":"","permalink":"http://boxianglin.github.io/2021/05/22/NumericallyPDE/","excerpt":"For phone user, the css might not be properly rendered for MathJax, please visit the pdf file at here Sample Partial Differential Equation \\begin{align*} &amp; \\text{Suppose given the PDE (Diffusion)} \\\\ &amp; \\partial_tu=D\\partial_x^2u,\\ for\\ x\\ \\in[0,1],and\\ t&gt;0\\\\ \\\\ &amp; \\text{Exact Solution (can be found in multiple PDEs textbooks): }\\\\ &amp; u(x,t) = \\sum_{k=1}^{n}=\\frac{4}{(k\\pi)^2}sin(\\frac{k\\pi}{2})sin(k\\pi x)e^{-0.5(k\\pi )^2t}\\\\ \\\\ &amp; \\text{We are going to compute the numerical solution with }\\\\ &amp; \\text{the given information below. }\\\\ \\\\ &amp; \\text{for }x \\in[0,1] \\text{ and t &gt; 0 :}\\\\ &amp; the\\ initial\\ condition\\ u(x,0)=\\begin{cases} x, &amp; \\text{if } 0\\leq x \\leq 1/2\\\\ 1-x, &amp; \\text{if } 1/2 &lt; x\\leq1 \\end{cases}\\\\ &amp;\\text{the boundary condition } u(0,t)=u(1,t)=0 \\\\ \\\\ &amp; \\text{The Explicit Difference Schema: }\\\\ &amp; \\frac{u_j^{n+1}-u_j^n}{\\Delta t}= D\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}, where\\ D=\\frac{1}{2}\\\\ \\\\ &amp;\\text{Take }\\Delta x=0.1, \\Delta t=1/100 \\text{ to proceed the calculations;} \\end{align*}","text":"For phone user, the css might not be properly rendered for MathJax, please visit the pdf file at here Sample Partial Differential Equation \\begin{align*} &amp; \\text{Suppose given the PDE (Diffusion)} \\\\ &amp; \\partial_tu=D\\partial_x^2u,\\ for\\ x\\ \\in[0,1],and\\ t&gt;0\\\\ \\\\ &amp; \\text{Exact Solution (can be found in multiple PDEs textbooks): }\\\\ &amp; u(x,t) = \\sum_{k=1}^{n}=\\frac{4}{(k\\pi)^2}sin(\\frac{k\\pi}{2})sin(k\\pi x)e^{-0.5(k\\pi )^2t}\\\\ \\\\ &amp; \\text{We are going to compute the numerical solution with }\\\\ &amp; \\text{the given information below. }\\\\ \\\\ &amp; \\text{for }x \\in[0,1] \\text{ and t &gt; 0 :}\\\\ &amp; the\\ initial\\ condition\\ u(x,0)=\\begin{cases} x, &amp; \\text{if } 0\\leq x \\leq 1/2\\\\ 1-x, &amp; \\text{if } 1/2 &lt; x\\leq1 \\end{cases}\\\\ &amp;\\text{the boundary condition } u(0,t)=u(1,t)=0 \\\\ \\\\ &amp; \\text{The Explicit Difference Schema: }\\\\ &amp; \\frac{u_j^{n+1}-u_j^n}{\\Delta t}= D\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}, where\\ D=\\frac{1}{2}\\\\ \\\\ &amp;\\text{Take }\\Delta x=0.1, \\Delta t=1/100 \\text{ to proceed the calculations;} \\end{align*} Solving Idea for a particular t \\begin{align*} &amp; \\text{Use of the finite difference scheme for discretizing partial derivatives}\\\\ &amp; \\text{reduces the problem to vector-matrix multiplication.}\\\\ \\\\ &amp; \\text{Where the unknown vector }U^n=(U_1^n,U_2^n,...U_N^n)^T\\text{ refers to sample}\\\\ &amp; \\text{of grid values of the solution function }u(x,t) \\text{ evaluated at } t = t_n.\\\\ \\\\ &amp; \\text{Then what we focuse on for }u_j^n=u(x_j,t_n) \\text{ is in a vector of }U^n to\\ U^{n+1} \\\\ \\\\ &amp; \\text{To calculated the }U^{n+1} , \\text{we must use the explicit difference scheme} \\end{align*} A Look of Explicit Difference Scheme Equation \\begin{align*} &amp; \\text{As we said we interested the vector }U^{n+1} = \\text{a set of } u_j^{n+1} j\\in[1,11],\\\\ &amp; \\text{for the case that }\\Delta x= 0.1, x\\in[0,1]\\\\ \\\\ &amp; \\text{Hence we would like to rearrange the equation to:}\\\\ \\\\ &amp; u_j^{n+1}= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}(u_{j+1}^n-2u_j^n+u_{j-1^n})+u_j^n\\\\ &amp; = u(x_j,t_{n+1})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_n)-2u(x_j,t_n)+u(x_{j-1},t_n)]+u(x_j,t_n)\\\\ \\\\ &amp; \\text{for easier programming purpose, we shift the index of t left by one}\\\\ &amp; = u(x_j,t_{n})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_{n-1})-2u(x_j,t_{n-1})+u(x_{j-1},t_{n-1})]+u(x_j,t_{n-1}) \\end{align*} A Look of How Initial and Boundary Condition are Important \\begin{align*} &amp; \\text{The expression of } u(x,t)\\text{ in 2D matrix: }\\\\ \\\\ &amp; \\begin{matrix} &amp; 1 &amp; 2&amp;3&amp; \\cdots&amp;n\\\\ 1&amp; u(0,0) &amp; u(0, 1\\Delta t) &amp; u(0,2\\Delta t) &amp; \\cdots &amp; u(0,n\\Delta t) \\\\ 2&amp; u(1 \\Delta x,0) &amp; \\cdots &amp; \\cdots&amp; \\cdots&amp; u(1\\Delta x,n\\Delta t) \\\\ 3&amp; u(2 \\Delta x, 0) &amp; \\cdots&amp; \\cdots&amp; \\cdots&amp; u(2\\Delta x,n\\Delta t)\\\\ &amp;.\\\\ &amp;. \\\\ 11&amp; u(1,0) &amp;\\end{matrix}\\\\ \\\\ &amp;\\text{The initial condition cover the values for first columns}\\\\ &amp;\\text{And the boundary condition cover the values for first and last rows}\\\\ \\\\ &amp;\\text{Now, the expression of }u(x,t) \\text{ should be:} \\\\ \\\\ &amp; \\begin{matrix} &amp; 1 &amp; 2&amp;3&amp; \\cdots&amp;n\\\\ 1&amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 2&amp; 0.1 &amp; u(1\\Delta x,1\\Delta t) &amp; \\cdots&amp; \\cdots&amp; u(1\\Delta x,n\\Delta t) \\\\ 3&amp; 0.2 &amp; u(2\\Delta x,1\\Delta t) &amp; \\cdots&amp; \\cdots&amp; u(2\\Delta x,n\\Delta t)\\\\ &amp;.\\\\ 5&amp; 0.5 &amp;\\cdots&amp; \\cdots&amp; \\cdots&amp; \\\\ 6&amp; 0.4 &amp; \\cdots&amp; \\cdots&amp; \\cdots&amp; \\\\ 7&amp; 0.3 &amp;\\cdots&amp; \\cdots&amp; \\cdots&amp; \\\\ &amp;. \\\\ 11&amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp;\\end{matrix}\\\\ \\\\ \\\\ &amp; \\text{Now from this matrix, we see the pattern of how explicit difference help}\\\\ &amp; \\text{us to calculate the } u(x_j,t_n);\\\\ \\\\ &amp; \\text{For example: }u(x_2,t_2),\\text{we need }u(x_1,t_1)，u(x_2,t_1),u(x_3,t_1)&#039;s \\text{ values}\\\\ &amp;\\text{to explicit difference equation: }\\\\ &amp; u(x_j,t_{n})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_{n-1})-2u(x_j,t_{n-1})+u(x_{j-1},t_{n-1})]+u(x_j,t_{n-1})\\\\ \\\\ &amp; \\text{Hence we know we must calculated the current columns&#039;s val then proceed to}\\\\ &amp; \\text{proceed to the row, }U^n = \\text{each columns value, and } U^{n+1} =\\text{next columns value} \\end{align*} MATLAB Implementations 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687clearclose allprompt = &#x27;Enter the value of ∆t: &#x27;;% set t_max= x then coloumns needed = x / delta_t + 1% row = 1/ (0.01) + 1 = 11 (by default x[0,1]delta_t = input(prompt);prompt1 = &#x27;Enter the value of T(max): &#x27;;column = input(prompt1) / delta_t + 1 ;row = 11;% 2-D array with all zeros for exact solutionarr1 = zeros(row,column);% initial variables for exact solutionresult = 0;arr1_x = 0;arr1_t = 0;% exact solution% taking 14 termsfor i = 1:row for j = 1:column for k = 1:14 result = result + 4/(k*pi)^2*sin(k*pi/2)*sin(k*pi*arr1_x)*exp(-0.5*(k*pi)^2*arr1_t); end arr1(i,j) = result; arr1_t = arr1_t + delta_t; result = 0; end arr1_t = 0; arr1_x = arr1_x + 0.1;end% Numerical Computing Solution% (Initial Condition)arr2 = zeros(row,column);x_num = 0;for i = 1 : row if(x_num&gt;0.5) arr2(i,1) = 1-x_num; else arr2(i,1) = x_num; end x_num = x_num + 0.1;end% applied explicit differences to calculate other points% applied boundary condition as welldt = delta_t;dx = 0.1;for j = 2: column for i = 1:row if (i == 1 || i == row) arr2(i,j) = 0; else arr2(i,j) =0.5 *dt/(dx)^2*(arr2(i+1, j-1)-2*arr2(i,j-1)+arr2(i-1,j-1))+arr2(i,j-1); end endend% Error |Exact - Numerical|error = zeros(row, column);for i = 1 : row for j = 1 : column error(i,j) = abs(arr1(i,j)- arr2(i,j)); endend%% plot Portionx_ = 0:0.1:1;prompt_1 = &#x27;Enter the value of t to get the graph u(x,t) at t =: &#x27; ;t = input(prompt_1);exctVal = arr1(:, t/delta_t+1 );numVal = arr2(:, t/delta_t+1 );plot (x_,numVal,x_,exctVal,&#x27;lineWidth&#x27;, 2);hold offxlabel(&#x27;x&#x27;);s = num2str(t);txt = [&#x27;u(x,t), t= &#x27;, s];ylabel(txt);legend(&#x27;Numerical&#x27;,&#x27;Exact&#x27;); Graphical Output","categories":[{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/categories/Numerical-Analysis/"}],"tags":[{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/tags/Numerical-Analysis/"}]},{"title":"Java-LinkedList-Insert","slug":"LinkedList-Insert","date":"2021-03-08T03:12:37.671Z","updated":"2021-09-06T04:19:03.281Z","comments":true,"path":"2021/03/07/LinkedList-Insert/","link":"","permalink":"http://boxianglin.github.io/2021/03/07/LinkedList-Insert/","excerpt":"Discussion: Read values from a file and insert values into a LinkedList data structure The goal is that at any point of the insertion the LinkedList should be in sorted First Approach Using the JAVA Library LinkedList We passing the file address into the run method’s parameter and do the try catch. 1234567891011121314class....&#123; private LinkedList&lt;Integer&gt; list = new new LinkedList&lt;Integer&gt;(); public void run(String address)&#123; try &#123; read_insert(address); //if address is valid, read it. &#125;catch(IOException e)&#123; e.printStackTrace(); //else, error resulted System.exit(0); //exist the program &#125; &#125;&#125; Using the Buffered-Reader to read values from the file. 12345678910public void read_insert(String address) throws IOException &#123; File text = new File(address); BufferedReader br1 = new BufferedReader(new FileReader(text)); String s = null; while((s=br1.readLine())!=null) &#123; //read line by line list.insert(Integer.parseInt(s)); //parse to int and pass to insert method &#125; br1.close();&#125;","text":"Discussion: Read values from a file and insert values into a LinkedList data structure The goal is that at any point of the insertion the LinkedList should be in sorted First Approach Using the JAVA Library LinkedList We passing the file address into the run method’s parameter and do the try catch. 1234567891011121314class....&#123; private LinkedList&lt;Integer&gt; list = new new LinkedList&lt;Integer&gt;(); public void run(String address)&#123; try &#123; read_insert(address); //if address is valid, read it. &#125;catch(IOException e)&#123; e.printStackTrace(); //else, error resulted System.exit(0); //exist the program &#125; &#125;&#125; Using the Buffered-Reader to read values from the file. 12345678910public void read_insert(String address) throws IOException &#123; File text = new File(address); BufferedReader br1 = new BufferedReader(new FileReader(text)); String s = null; while((s=br1.readLine())!=null) &#123; //read line by line list.insert(Integer.parseInt(s)); //parse to int and pass to insert method &#125; br1.close();&#125; Now we created a insert method to inserting each value that pass in from the Buffered-Reader. 123456789101112131415161718public void insert(int value) &#123; if(list.size() == 0 || value &lt; list.getFirst() ) &#123; list.addFirst(value); //insert at the head if list is empty and //if val &lt; head&#x27;s val &#125; else if(value &gt; list.getLast() ) &#123; list.addLast(value); //insert to the tail if val &gt; tail&#x27;s value &#125; else &#123; Iterator&lt;Integer&gt; it = list.iterator(); int index = 0; while(it.hasNext() &amp;&amp; value &gt;= it.next())&#123; index ++; //if the list is not empty and val still &gt;= list&#x27;s //next value, index keep increases by 1 &#125; list.add(index,value); //usingg the java library to add the value at specific index. &#125;&#125; **The insert runtime complexity is O(N + N) = O(N) ** **NOTICE: **The runtime complexity could be worst to O(N^2) if our insert algorithm suppose as below: 123456789101112131415161718public void insert(int value) &#123; if(list.size() == 0 || value &lt; list.getFirst() ) &#123; list.addFirst(value); //insert at the head if list is empty and //if val &lt; head&#x27;s val &#125; else if(value &gt; list.getLast() ) &#123; list.addLast(value); //insert to the tail if val &gt; tail&#x27;s value &#125; else &#123; for(int i = 0; i&lt;list.size(); i++)&#123; if(val&lt;list.get(i))&#123; list.add(i,value); break; &#125; &#125; &#125;&#125; Second Approach Using Self-Define Singly LinkedList We know that LinkedList data structure basically is objects that linked to each other, each object contains some value Singly LinkedList looks like this: that each of the rectangle is a object, value is inside of the object, and arrow is the self-define data type that help to connect up the object, often we using the object as a data type for the arrow **Now our object that to store the value will be as follows: ** 12345678class ListNode&#123; int val; ListNode next; //arrow public ListNode(int val) &#123; this.val = val; &#125;&#125; and our LinkedList is a collection of the ListNodes 1234567891011public class SingleLinkedList &#123; ListNode head; int size; public SingleLinkedList() &#123; size = 0; head = null; &#125;&#125; OKAY, So now lets implementing the insert method: same idea as the previous one but instead now we are creating our own LinkList instead of using the java library. So we will be do some mollifications to the add(index, val) method that was in Java Library. Suppose we are inserting 3 to the LinkedList: We will let 3 --&gt; 4 first, then let 2 --&gt; 3. So, lets do it to the codes 12345678910111213141516171819202122232425public void insert(int data) &#123; //list is empty or val that greater than first node&#x27;s value, swap them if(head == null || head.val &gt; data) &#123; ListNode newHead= new ListNode(data); newHead.next = head; head = newHead; size++; &#125;else &#123; //cur as a temporary node that use to traverse the list ListNode cur = head; while(cur.next != null &amp;&amp; cur.next.val&lt;data) &#123; cur = cur.next; //if value greater than node&#x27;s value, keep going &#125; if(cur.next == null) &#123; //case to put the value to the tail ListNode nextVal = new ListNode(data); cur.next = nextVal; size++; &#125;else &#123; //case to insert ListNode newNext = new ListNode(data); newNext.next = cur.next; //cur.next point to the new val cur.next = newNext; //new val then be the new cur.next size++; &#125; &#125; &#125; This algorithm of insert takes runtime of O(N), we are basically traverse through the list and doing some pointing direction change necessary","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/tags/Data-Structure/"}]}],"categories":[{"name":"Automata and Formal Languages","slug":"Automata-and-Formal-Languages","permalink":"http://boxianglin.github.io/categories/Automata-and-Formal-Languages/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/categories/Algorithms/"},{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/categories/Numerical-Analysis/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/categories/Data-Structure/"}],"tags":[{"name":"Automata and Formal Languages","slug":"Automata-and-Formal-Languages","permalink":"http://boxianglin.github.io/tags/Automata-and-Formal-Languages/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/tags/Algorithms/"},{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/tags/Numerical-Analysis/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/tags/Data-Structure/"}]}