{"meta":{"title":"Boxiang's Blog","subtitle":"","description":"","author":"Boxiang Lin","url":"http://boxianglin.github.io","root":"/"},"pages":[{"title":"About me","date":"2021-06-07T06:08:51.121Z","updated":"2021-06-07T06:08:51.121Z","comments":true,"path":"about/index.html","permalink":"http://boxianglin.github.io/about/index.html","excerpt":"","text":"More to show later"},{"title":"projects","date":"2021-05-27T06:01:22.092Z","updated":"2021-05-27T06:01:22.092Z","comments":true,"path":"projects/index.html","permalink":"http://boxianglin.github.io/projects/index.html","excerpt":"","text":"Click to run!"},{"title":"tags","date":"2021-03-08T01:25:13.881Z","updated":"2021-03-08T01:25:13.881Z","comments":true,"path":"tags/index.html","permalink":"http://boxianglin.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-03-08T01:23:54.052Z","updated":"2021-03-08T01:23:54.052Z","comments":true,"path":"categories/index.html","permalink":"http://boxianglin.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Compute the time available for meetings","slug":"MeetingsCompute","date":"2021-06-16T05:18:24.353Z","updated":"2021-07-07T17:41:36.591Z","comments":true,"path":"2021/06/15/MeetingsCompute/","link":"","permalink":"http://boxianglin.github.io/2021/06/15/MeetingsCompute/","excerpt":"Phone users pls visit the pdf here Generate a List of Available Time for Meetings Input: Person1: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Person2: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Meeting_time frame: 30 minutes at least Output: Return a nested list of all available time to schedule meetings for Person1 and Person2 example: 12345678Input:p1_schedule &#x3D; [[&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;],[&#39;18:30&#39;,&#39;19:00&#39;]]p2_schedule &#x3D; [[&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;]]p1_daily_bound &#x3D; [&#39;9:00&#39;,&#39;20:00&#39;]p2_daily_bound &#x3D; [&#39;10:00&#39;,&#39;18:30&#39;]meeting_time &#x3D; 30output: [[&#39;15:00&#39;, &#39;16:00&#39;], [&#39;18:00&#39;, &#39;18:30&#39;]]","text":"Phone users pls visit the pdf here Generate a List of Available Time for Meetings Input: Person1: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Person2: Given a nested list of current schedule person1 currently hold; a list of person's daily bound Meeting_time frame: 30 minutes at least Output: Return a nested list of all available time to schedule meetings for Person1 and Person2 example: 12345678Input:p1_schedule &#x3D; [[&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;],[&#39;18:30&#39;,&#39;19:00&#39;]]p2_schedule &#x3D; [[&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;]]p1_daily_bound &#x3D; [&#39;9:00&#39;,&#39;20:00&#39;]p2_daily_bound &#x3D; [&#39;10:00&#39;,&#39;18:30&#39;]meeting_time &#x3D; 30output: [[&#39;15:00&#39;, &#39;16:00&#39;], [&#39;18:00&#39;, &#39;18:30&#39;]] Pre 1. Formal Definition of Input \\begin{align*} &amp; \\text{Suppose } P \\text{ is a list of schedules for a particular day that contains } t _{(i,j)}^{N} \\text{ where t is a schedule between i to j time at Nth index of P } \\\\ &amp; \\text{We are also given a list of B that map to a P, where B contains two values } B_0\\ and \\ B_1 \\\\ &amp; \\text{Now, each input comply with the conditions below: }\\\\ &amp; \\text{} \\end{align*} \\begin{align*} &amp; p1.1)\\ B_0 \\leq [ t_{(i,j)}^N \\in P] \\leq B_1 \\\\ &amp; p1.2)\\ t_i &lt; t_j \\leq t_{i+1} &lt; t_{j+1} \\leq t_{N=i}&lt;t_{N=j}\\\\ \\end{align*} Pre 2. Formal Definition of Output \\begin{align*} &amp; \\text{Suppose O list contains time segments } T_{(i,j)}^M \\text{, O should be comply with below conditions} \\\\ \\\\ &amp; \\text{Suppose, }\\Delta t1_N = (t1_{j=0},t1_{i=1}),.....,(t1_{j=N-1},t1_{i=N}), \\text{so is } \\Delta t2_N\\\\ &amp; p2.1)\\ \\forall T_{(i,j)}^M \\not \\subset (\\Delta t1_N + \\Delta t2_N) \\\\ &amp; p2.2)\\ Max(B(0)_0, B(1)_0) \\leq \\forall\\ T_{(i,j)}^M \\leq Min(B(0)_0, B(1)_1) \\text{ where $B(x)$, $x$ represent a particular person}\\\\ &amp; p2.3)\\ T_i &lt; T_j \\leq T_{i+1 } &lt; T_{j+1} \\end{align*} Step 1. Determine The Final Bound Between Two Persons Pick the largest B0B_0B0​ and smallest B1B_1B1​ between B(x)B(x)B(x) to be Final Bound, we have to use this to cut off the out-of-bound time segments. $ s1.1) finalBound = [max(B(0)_0,B(1)_0,min(B(0)_1,B(1)_1)]$ Step 2. Combine Both P lists Since we know schedules of each P in sorted. We could merge both P lists by sorted order of tit_iti​. Let the merge list called CCC, then CCC has this unique condition to be aware of: s2.1) ∀C(i,j)N1+N2=S,Ci≤Cj and Ci≤Ci+1 holds, but Cj≰Ci+1 and Cj≰Cj+1 turns out to be not necessarys2.1)\\ \\forall C_{(i,j)}^{N1+N2 = S},C_i \\leq C_j \\ and\\ C_i\\leq C_{i+1} \\text{ holds, but } C_{j} \\not \\leq C_{i+1} \\ and \\ C_j\\not \\leq C_{j+1} \\text{ turns out to be not necessary} s2.1) ∀C(i,j)N1+N2=S​,Ci​≤Cj​ and Ci​≤Ci+1​ holds, but Cj​​≤Ci+1​ and Cj​​≤Cj+1​ turns out to be not necessary 12Take the example above:C &#x3D; [[&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;], [&#39;18:30&#39;, &#39;19:00&#39;]] Notice from above example: $C_{j=0} (‘10:45’) &gt; C_{i=1}(‘10:00’) $ and $C_{j=0} (‘10:45’) &gt; C_{j=1}(‘10:30’) $ Step 3. Trim The Combine List We have to trim the Combine List, the purpose is to trim the C list to below condition: \\begin{align*} &amp; s3.1) \\text{Place the upper bound to first index } C= [finalBound[0],finalBound[0]]+C_{i,j}^S\\\\ &amp; s3.2) \\ \\forall C_{i}^{S},\\forall C_j^S\\leq finalBound[1] \\text{ , To acheive this we have to do the followings combine list modifications :} \\\\ \\end{align*} \\begin{align*} &amp; =\\begin{cases} C_i^S \\geq finalBound[1], &amp; \\text{Remove current } C_{i,j}^S \\\\ C_i^S\\leq finalBound[1] \\ and\\ C_j^S&gt;finalBound[1], &amp; finalBound[1] = C_i^s \\text{ (We pick the smallest possible i) and } C_j^S=C_i^S \\end{cases} \\\\ \\\\ &amp; s3.3) \\text{Append [finalBound[1],finalBound[1]] to C} \\end{align*} finalBound for the example is = [‘10:00’,‘18:30’]: After s3.1, s3.2, s.3.3, C for the example above will be: 1C &#x3D; [[&#39;10:00&#39;, &#39;10:00&#39;], [&#39;9:00&#39;, &#39;10:45&#39;], [&#39;10:00&#39;, &#39;10:30&#39;], [&#39;10:30&#39;, &#39;14:30&#39;], [&#39;10:45&#39;, &#39;13:00&#39;], [&#39;14:30&#39;, &#39;15:00&#39;], [&#39;16:00&#39;, &#39;17:00&#39;], [&#39;16:00&#39;, &#39;18:00&#39;], [&#39;18:30&#39;, &#39;18:30&#39;]] Step 4. Main Logic: Compute the O (Output) Lets first assuming our C has this inequality relation Ci≤Cj≤Ci+1≤Cj+1C_i\\leq C_j \\leq C_{i+1} \\leq C_{j+1}Ci​≤Cj​≤Ci+1​≤Cj+1​ then we are confident to say that each $ [C_j, C_{i+1}] = T_{i = j,j = i+1} if\\ \\geq 30\\ minutes$ is a solution. Why? \\begin{align*} &amp; \\text{Proof}\\\\ &amp; \\text{Given the above inequality C possess of, and indecies are defined and bounded }i,j \\in \\mathbb{Z}, 0\\leq i,j\\leq S;\\\\ &amp; \\text{We know: }[finalBound[0], finalBound[1]] = [C_{i=0},C_{j=0})+[C_{i=0},C_{j=1}]+(C_i,C_j)+[C_{i=j},C_{i+1}]+.....(C_{i=S},C_{j=S}] \\\\ &amp; \\text{By definition of this sorted inequality, this shows each single C that sums up the the range in finalBound does not have overlaps} \\\\ &amp; \\text{Hence, }\\forall [C_{j,}, C_{i+1}] \\text{ are the solutions because } = 1-(C_{0&lt;i&lt;S}^S,C_{0&lt;j&lt;S}^S)-[C_{i0},C_{j0})-(C_{iS},C_{jS}]. \\end{align*} Which turns out if Cj&gt;Ci+1 or Cj&gt;Cj+1C_j &gt; C_{i+1} \\ or\\ C_j &gt; C_{j+1}Cj​&gt;Ci+1​ or Cj​&gt;Cj+1​ the [Cj,Ci+1][C_j, C_{i+1}][Cj​,Ci+1​] is not a solution, intuitively, that the first case resulting negative time range, and second case producing overlaps which shows (Ci,Cj)⊆[Cj,Ci+1](C_i, C_j) \\subseteq [C_j, C_{i+1}](Ci​,Cj​)⊆[Cj​,Ci+1​] \\begin{align*} &amp; \\text{Mechanism is to loop through the C list from index 0 to S and do the followings each iteration: }\\\\ \\\\ &amp; =\\begin{cases} C_j&gt;C_{i+1}\\ and\\ C_j\\leq C_{j+1} , &amp; \\text{Skip Current } C_{i,j} \\\\ C_j&gt;C_{i+1}\\ and\\ C_j&gt; C_{j+1} , &amp; \\text{Skip Current } C_{i,j} \\text{ and marked } C_{j+1} = C_j \\\\ C_j \\leq C_{i+1} \\ then \\ of \\ course\\ C_j\\leq C_{j+1},&amp; [C_j,C_{i+1}] \\text{ is solution if } \\geq 30\\ min \\\\ \\end{cases} \\\\ \\end{align*} Python Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111##################################---MAIN FUNCTION --- ##################################def aSchedule(p1S, p2S, p1B, p2B, meet_time): res = [] #Step 1 final_bound = dailyBound(p1B, p2B) #Step 2 and 3 combineS = combine(p1S, p2S,final_bound) temp_end = [] #Step 4 for i in range(1, len(combineS)): if temp_end: prev_end = temp_end[0] temp_end.pop() else: prev_end = combineS[i - 1][1] start = combineS[i][0] end = combineS[i][1] # Main Logic----- if compare(start, prev_end) &lt;= 0: # if end &lt; prev_end, prev_end should be the next (prev_end) to compare with the start if compare(end,prev_end) &lt; 0: temp_end.append(prev_end) elif compare(start, prev_end) &gt; 0: # start &gt; prev_end if difference(prev_end, start) &gt;= meet_time: # start - prev_end &gt;= meet_time res.append([prev_end, start]) return res###################################################################################def dailyBound(p1B, p2B): finalBound = [] # pick largest start if compare(p1B[0],p2B[0]) &gt;= 0: finalBound.append(p1B[0]) else: finalBound.append(p2B[0]) # pick smallest start if compare(p1B[1],p2B[1]) &lt;= 0: finalBound.append(p1B[1]) else: finalBound.append(p2B[1]) return finalBound## &lt;&lt;Helper&gt;&gt; combine two sorted nested array#def combine(p1S, p2S,final_bound): combine = [] combine.append([final_bound[0],final_bound[0]]) i, j = 0, 0 while i &lt; len(p1S) and j &lt; len(p2S): if compare(p1S[i][0], p2S[j][0]) &lt; 0: combine.append(p1S[i]) i += 1 else: combine.append(p2S[j]) j += 1 while i &lt; len(p1S): combine.append(p1S[i]) i += 1 while j &lt; len(p2S): combine.append(p2S[j]) j += 1 # Remove the largest schedule beyong the final_bound and search for potentially new end bound new_bound = [] for i in range(len(combine)): # when start &lt; finalbound but end &gt;= finalbound, [i] = [start,start] if compare(combine[i][0],final_bound[1]) &lt;= 0 and compare(combine[i][1], final_bound[1]) &gt; 0: combine[i] = [combine[i][0],combine[i][0]] if not new_bound: #we only take the first encounter one to be new bound new_bound.append(combine[i][0]) final_bound[1] = new_bound[0] # since the prev if condition valid, this will not execute, but next loops it will remove start &gt;= finalBound if compare(combine[i][0],final_bound[1]) &gt;= 0: combine.remove(combine[i]) combine.append([final_bound[1],final_bound[1]]) return combine## &lt;&lt;Helper&gt;&gt; compare#def compare(t1, t2): hr1, min1 = t1.split(&#x27;:&#x27;) hr2, min2 = t2.split(&#x27;:&#x27;) t1 = int(hr1) * 60 + int(min1) # t1 total minutes t2 = int(hr2) * 60 + int(min2) # t2 total minutes if t1 &lt; t2: return -1 elif t1 &gt; t2: return 1 else: return 0def difference(t1, t2): hr1, min1 = t1.split(&#x27;:&#x27;) hr2, min2 = t2.split(&#x27;:&#x27;) t1 = int(hr1) * 60 + int(min1) # t1 total minutes t2 = int(hr2) * 60 + int(min2) # t2 total minutes return t2 - t1p1S = [[&#x27;9:00&#x27;, &#x27;10:45&#x27;], [&#x27;10:45&#x27;, &#x27;13:00&#x27;], [&#x27;16:00&#x27;, &#x27;18:00&#x27;],[&#x27;18:30&#x27;,&#x27;19:00&#x27;]]p2S = [[&#x27;10:00&#x27;, &#x27;10:30&#x27;], [&#x27;10:30&#x27;, &#x27;14:30&#x27;], [&#x27;14:30&#x27;, &#x27;15:00&#x27;], [&#x27;16:00&#x27;, &#x27;17:00&#x27;]]p1B = [&#x27;9:00&#x27;,&#x27;20:00&#x27;]p2B = [&#x27;10:00&#x27;,&#x27;18:30&#x27;]print(aSchedule(p1S, p2S, p1B, p2B, 30))","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/categories/Algorithms/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/tags/Algorithms/"}]},{"title":"Numerically Solve PDE","slug":"NumericallyPDE","date":"2021-05-23T00:23:13.928Z","updated":"2021-05-28T04:33:21.287Z","comments":true,"path":"2021/05/22/NumericallyPDE/","link":"","permalink":"http://boxianglin.github.io/2021/05/22/NumericallyPDE/","excerpt":"For phone user, the css might not be properly rendered for MathJax, please visitthe pdf file at here Sample Partial Differential Equation \\begin{align*} & \\text{Suppose given the PDE (Diffusion)} \\\\ & \\partial_tu=D\\partial_x^2u,\\ for\\ x\\ \\in[0,1],and\\ t>0\\\\ \\\\ & \\text{Exact Solution (can be found in multiple PDEs textbooks): }\\\\ & u(x,t) = \\sum_{k=1}^{n}=\\frac{4}{(k\\pi)^2}sin(\\frac{k\\pi}{2})sin(k\\pi x)e^{-0.5(k\\pi )^2t}\\\\ \\\\ & \\text{We are going to compute the numerical solution with }\\\\ & \\text{the given information below. }\\\\ \\\\ & \\text{for }x \\in[0,1] \\text{ and t > 0 :}\\\\ & the\\ initial\\ condition\\ u(x,0)=\\begin{cases} x, & \\text{if } 0\\leq x \\leq 1/2\\\\ 1-x, & \\text{if } 1/2 < x\\leq1 \\end{cases}\\\\ &\\text{the boundary condition } u(0,t)=u(1,t)=0 \\\\ \\\\ & \\text{The Explicit Difference Schema: }\\\\ & \\frac{u_j^{n+1}-u_j^n}{\\Delta t}= D\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}, where\\ D=\\frac{1}{2}\\\\ \\\\ &\\text{Take }\\Delta x=0.1, \\Delta t=1/100 \\text{ to proceed the calculations;} \\end{align*}","text":"For phone user, the css might not be properly rendered for MathJax, please visitthe pdf file at here Sample Partial Differential Equation \\begin{align*} & \\text{Suppose given the PDE (Diffusion)} \\\\ & \\partial_tu=D\\partial_x^2u,\\ for\\ x\\ \\in[0,1],and\\ t>0\\\\ \\\\ & \\text{Exact Solution (can be found in multiple PDEs textbooks): }\\\\ & u(x,t) = \\sum_{k=1}^{n}=\\frac{4}{(k\\pi)^2}sin(\\frac{k\\pi}{2})sin(k\\pi x)e^{-0.5(k\\pi )^2t}\\\\ \\\\ & \\text{We are going to compute the numerical solution with }\\\\ & \\text{the given information below. }\\\\ \\\\ & \\text{for }x \\in[0,1] \\text{ and t > 0 :}\\\\ & the\\ initial\\ condition\\ u(x,0)=\\begin{cases} x, & \\text{if } 0\\leq x \\leq 1/2\\\\ 1-x, & \\text{if } 1/2 < x\\leq1 \\end{cases}\\\\ &\\text{the boundary condition } u(0,t)=u(1,t)=0 \\\\ \\\\ & \\text{The Explicit Difference Schema: }\\\\ & \\frac{u_j^{n+1}-u_j^n}{\\Delta t}= D\\frac{u_{j+1}^n-2u_j^n+u_{j-1}^n}{(\\Delta x)^2}, where\\ D=\\frac{1}{2}\\\\ \\\\ &\\text{Take }\\Delta x=0.1, \\Delta t=1/100 \\text{ to proceed the calculations;} \\end{align*} Solving Idea for a particular t \\begin{align*} & \\text{Use of the finite difference scheme for discretizing partial derivatives}\\\\ & \\text{reduces the problem to vector-matrix multiplication.}\\\\ \\\\ & \\text{Where the unknown vector }U^n=(U_1^n,U_2^n,...U_N^n)^T\\text{ refers to sample}\\\\ & \\text{of grid values of the solution function }u(x,t) \\text{ evaluated at } t = t_n.\\\\ \\\\ & \\text{Then what we focuse on for }u_j^n=u(x_j,t_n) \\text{ is in a vector of }U^n to\\ U^{n+1} \\\\ \\\\ & \\text{To calculated the }U^{n+1} , \\text{we must use the explicit difference scheme} \\end{align*}A Look of Explicit Difference Scheme Equation \\begin{align*} & \\text{As we said we interested the vector }U^{n+1} = \\text{a set of } u_j^{n+1} j\\in[1,11],\\\\ & \\text{for the case that }\\Delta x= 0.1, x\\in[0,1]\\\\ \\\\ & \\text{Hence we would like to rearrange the equation to:}\\\\ \\\\ & u_j^{n+1}= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}(u_{j+1}^n-2u_j^n+u_{j-1^n})+u_j^n\\\\ & = u(x_j,t_{n+1})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_n)-2u(x_j,t_n)+u(x_{j-1},t_n)]+u(x_j,t_n)\\\\ \\\\ & \\text{for easier programming purpose, we shift the index of t left by one}\\\\ & = u(x_j,t_{n})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_{n-1})-2u(x_j,t_{n-1})+u(x_{j-1},t_{n-1})]+u(x_j,t_{n-1}) \\end{align*}A Look of How Initial and Boundary Condition are Important \\begin{align*} & \\text{The expression of } u(x,t)\\text{ in 2D matrix: }\\\\ \\\\ & \\begin{matrix} & 1 & 2&3& \\cdots&n\\\\ 1& u(0,0) & u(0, 1\\Delta t) & u(0,2\\Delta t) & \\cdots & u(0,n\\Delta t) \\\\ 2& u(1 \\Delta x,0) & \\cdots & \\cdots& \\cdots& u(1\\Delta x,n\\Delta t) \\\\ 3& u(2 \\Delta x, 0) & \\cdots& \\cdots& \\cdots& u(2\\Delta x,n\\Delta t)\\\\ &.\\\\ &. \\\\ 11& u(1,0) &\\end{matrix}\\\\ \\\\ &\\text{The initial condition cover the values for first columns}\\\\ &\\text{And the boundary condition cover the values for first and last rows}\\\\ \\\\ &\\text{Now, the expression of }u(x,t) \\text{ should be:} \\\\ \\\\ & \\begin{matrix} & 1 & 2&3& \\cdots&n\\\\ 1& 0 & 0 & 0 & \\cdots & 0 \\\\ 2& 0.1 & u(1\\Delta x,1\\Delta t) & \\cdots& \\cdots& u(1\\Delta x,n\\Delta t) \\\\ 3& 0.2 & u(2\\Delta x,1\\Delta t) & \\cdots& \\cdots& u(2\\Delta x,n\\Delta t)\\\\ &.\\\\ 5& 0.5 &\\cdots& \\cdots& \\cdots& \\\\ 6& 0.4 & \\cdots& \\cdots& \\cdots& \\\\ 7& 0.3 &\\cdots& \\cdots& \\cdots& \\\\ &. \\\\ 11& 0 & 0 & 0 & \\cdots & 0 &\\end{matrix}\\\\ \\\\ \\\\ & \\text{Now from this matrix, we see the pattern of how explicit difference help}\\\\ & \\text{us to calculate the } u(x_j,t_n);\\\\ \\\\ & \\text{For example: }u(x_2,t_2),\\text{we need }u(x_1,t_1)，u(x_2,t_1),u(x_3,t_1)'s \\text{ values}\\\\ &\\text{to explicit difference equation: }\\\\ & u(x_j,t_{n})= \\frac{1}{2}\\frac{\\Delta t}{(\\Delta x)^2}[u(x_{j+1},t_{n-1})-2u(x_j,t_{n-1})+u(x_{j-1},t_{n-1})]+u(x_j,t_{n-1})\\\\ \\\\ & \\text{Hence we know we must calculated the current columns's val then proceed to}\\\\ & \\text{proceed to the row, }U^n = \\text{each columns value, and } U^{n+1} =\\text{next columns value} \\end{align*}MATLAB Implementations123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687clearclose allprompt = &#x27;Enter the value of ∆t: &#x27;;% set t_max= x then coloumns needed = x / delta_t + 1% row = 1/ (0.01) + 1 = 11 (by default x[0,1]delta_t = input(prompt);prompt1 = &#x27;Enter the value of T(max): &#x27;;column = input(prompt1) / delta_t + 1 ;row = 11;% 2-D array with all zeros for exact solutionarr1 = zeros(row,column);% initial variables for exact solutionresult = 0;arr1_x = 0;arr1_t = 0;% exact solution% taking 14 termsfor i = 1:row for j = 1:column for k = 1:14 result = result + 4/(k*pi)^2*sin(k*pi/2)*sin(k*pi*arr1_x)*exp(-0.5*(k*pi)^2*arr1_t); end arr1(i,j) = result; arr1_t = arr1_t + delta_t; result = 0; end arr1_t = 0; arr1_x = arr1_x + 0.1;end% Numerical Computing Solution% (Initial Condition)arr2 = zeros(row,column);x_num = 0;for i = 1 : row if(x_num&gt;0.5) arr2(i,1) = 1-x_num; else arr2(i,1) = x_num; end x_num = x_num + 0.1;end% applied explicit differences to calculate other points% applied boundary condition as welldt = delta_t;dx = 0.1;for j = 2: column for i = 1:row if (i == 1 || i == row) arr2(i,j) = 0; else arr2(i,j) =0.5 *dt/(dx)^2*(arr2(i+1, j-1)-2*arr2(i,j-1)+arr2(i-1,j-1))+arr2(i,j-1); end endend% Error |Exact - Numerical|error = zeros(row, column);for i = 1 : row for j = 1 : column error(i,j) = abs(arr1(i,j)- arr2(i,j)); endend%% plot Portionx_ = 0:0.1:1;prompt_1 = &#x27;Enter the value of t to get the graph u(x,t) at t =: &#x27; ;t = input(prompt_1);exctVal = arr1(:, t/delta_t+1 );numVal = arr2(:, t/delta_t+1 );plot (x_,numVal,x_,exctVal,&#x27;lineWidth&#x27;, 2);hold offxlabel(&#x27;x&#x27;);s = num2str(t);txt = [&#x27;u(x,t), t= &#x27;, s];ylabel(txt);legend(&#x27;Numerical&#x27;,&#x27;Exact&#x27;); Graphical Output","categories":[{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/categories/Numerical-Analysis/"}],"tags":[{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/tags/Numerical-Analysis/"}]},{"title":"Java-LinkedList-Insert","slug":"LinkedList-Insert","date":"2021-03-08T03:12:37.671Z","updated":"2021-05-23T00:18:58.286Z","comments":true,"path":"2021/03/07/LinkedList-Insert/","link":"","permalink":"http://boxianglin.github.io/2021/03/07/LinkedList-Insert/","excerpt":"Discussion: Read values from a file and insert values into a LinkedList data structure The goal is that at any point of the insertion the LinkedList should be in sorted First Approach Using the JAVA Library LinkedList We passing the file address into the run method’s parameter and do the try catch. 1234567891011121314class....&#123; private LinkedList&lt;Integer&gt; list = new new LinkedList&lt;Integer&gt;(); public void run(String address)&#123; try &#123; read_insert(address); //if address is valid, read it. &#125;catch(IOException e)&#123; e.printStackTrace(); //else, error resulted System.exit(0); //exist the program &#125; &#125;&#125; Using the Buffered-Reader to read values from the file. 12345678910public void read_insert(String address) throws IOException &#123; File text = new File(address); BufferedReader br1 = new BufferedReader(new FileReader(text)); String s = null; while((s=br1.readLine())!=null) &#123; //read line by line list.insert(Integer.parseInt(s)); //parse to int and pass to insert method &#125; br1.close();&#125;","text":"Discussion: Read values from a file and insert values into a LinkedList data structure The goal is that at any point of the insertion the LinkedList should be in sorted First Approach Using the JAVA Library LinkedList We passing the file address into the run method’s parameter and do the try catch. 1234567891011121314class....&#123; private LinkedList&lt;Integer&gt; list = new new LinkedList&lt;Integer&gt;(); public void run(String address)&#123; try &#123; read_insert(address); //if address is valid, read it. &#125;catch(IOException e)&#123; e.printStackTrace(); //else, error resulted System.exit(0); //exist the program &#125; &#125;&#125; Using the Buffered-Reader to read values from the file. 12345678910public void read_insert(String address) throws IOException &#123; File text = new File(address); BufferedReader br1 = new BufferedReader(new FileReader(text)); String s = null; while((s=br1.readLine())!=null) &#123; //read line by line list.insert(Integer.parseInt(s)); //parse to int and pass to insert method &#125; br1.close();&#125; Now we created a insert method to inserting each value that pass in from the Buffered-Reader. 123456789101112131415161718public void insert(int value) &#123; if(list.size() == 0 || value &lt; list.getFirst() ) &#123; list.addFirst(value); //insert at the head if list is empty and //if val &lt; head&#x27;s val &#125; else if(value &gt; list.getLast() ) &#123; list.addLast(value); //insert to the tail if val &gt; tail&#x27;s value &#125; else &#123; Iterator&lt;Integer&gt; it = list.iterator(); int index = 0; while(it.hasNext() &amp;&amp; value &gt;= it.next())&#123; index ++; //if the list is not empty and val still &gt;= list&#x27;s //next value, index keep increases by 1 &#125; list.add(index,value); //usingg the java library to add the value at specific index. &#125;&#125; The insert runtime complexity is O(N + N) = O(N) NOTICE: The runtime complexity could be worst to O(N^2) if our insert algorithm suppose as below: 123456789101112131415161718public void insert(int value) &#123; if(list.size() == 0 || value &lt; list.getFirst() ) &#123; list.addFirst(value); //insert at the head if list is empty and //if val &lt; head&#x27;s val &#125; else if(value &gt; list.getLast() ) &#123; list.addLast(value); //insert to the tail if val &gt; tail&#x27;s value &#125; else &#123; for(int i = 0; i&lt;list.size(); i++)&#123; if(val&lt;list.get(i))&#123; list.add(i,value); break; &#125; &#125; &#125;&#125; This algorithm is not good in runtime and often time algorithm that involve break is not safe, however, this algorithm might be OKAY for a small size of values file but cause runtime error if size of file is large Second Approach Using Self-Define Singly LinkedList We know that LinkedList data structure basically is objects that linked to each other, each object contains some value Singly LinkedList looks like this: that each of the rectangle is a object, value is inside of the object, and arrow is the self-define data type that help to connect up the object, often we using the object as a data type for the arrow Now our object that to store the value will be as follows: 12345678class ListNode&#123; int val; ListNode next; //arrow public ListNode(int val) &#123; this.val = val; &#125;&#125; and our LinkedList is a collection of the ListNodes 1234567891011public class SingleLinkedList &#123; ListNode head; int size; public SingleLinkedList() &#123; size = 0; head = null; &#125;&#125; OKAY, So now lets implementing the insert method: same idea as the previous one but instead now we are creating our own LinkList instead of using the java library. So we will be do some mollifications to the add(index, val) method that was in Java Library. Suppose we are inserting 3 to the LinkedList: We will let 3 —&gt; 4 first, then let 2 —&gt; 3. So, lets do it to the codes 12345678910111213141516171819202122232425public void insert(int data) &#123; //list is empty or val that greater than first node&#x27;s value, swap them if(head == null || head.val &gt; data) &#123; ListNode newHead= new ListNode(data); newHead.next = head; head = newHead; size++; &#125;else &#123; //cur as a temporary node that use to traverse the list ListNode cur = head; while(cur.next != null &amp;&amp; cur.next.val&lt;data) &#123; cur = cur.next; //if value greater than node&#x27;s value, keep going &#125; if(cur.next == null) &#123; //case to put the value to the tail ListNode nextVal = new ListNode(data); cur.next = nextVal; size++; &#125;else &#123; //case to insert ListNode newNext = new ListNode(data); newNext.next = cur.next; //cur.next point to the new val cur.next = newNext; //new val then be the new cur.next size++; &#125; &#125; &#125; This algorithm of insert takes runtime of O(N), we are basically traverse through the list and doing some pointing direction change necessary Alright! This is two approach for insert algorithm that to main the list sorted at any given point. I will upload the full version of the codes on my GitHub shortly.","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/categories/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/tags/Data-Structure/"}]}],"categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/categories/Algorithms/"},{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/categories/Numerical-Analysis/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/categories/Data-Structure/"}],"tags":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://boxianglin.github.io/tags/Algorithms/"},{"name":"Numerical Analysis","slug":"Numerical-Analysis","permalink":"http://boxianglin.github.io/tags/Numerical-Analysis/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://boxianglin.github.io/tags/Data-Structure/"}]}